package atom_core;

import lejos.hardware.Button;
import lejos.hardware.Sound;
import lejos.hardware.lcd.LCD;

class Core
  extends Setup
{ 
  public static void play()
  {
	 Sound.playTone(550, 500);
	 LCD.drawString("---Running---", 0, 3);
	
	 //Variabili utilizzate per contenere i valori rilevati dalla lettura dei sensori
	 float[] colorInputR;
	 float[] colorInputL;
	 float[] colorInputSilverR;
	 float[] colorInputSilverL;
	 float ultrasonicUPInput;
	 float ultrasonicDownInput;
	 
	 //Costante relativa alla velocità da utilizzare nelle curve
	 final int steeringSpeed = 200;
	 
	 /*Variabile utilizzata per memorizzare l'ultima mossa effettuata, aiuta a risolvere le ambiguità generate
	  *dal caso NERO-NERO*/
	 //f-r-l forward, right, left
	 String lastMove = "";
	 
	 //Loop principale di esecuzione, si ripete finché non viene premuto il tasto di uscita
	 while(Button.getButtons() != Button.ID_ESCAPE)
	 {
		 //Lettura dei valori dei sensori tramite le "librerie" ColorUtils e UltrasonicUtils
		 colorInputR = ColorUtils.getValues(RColor);
		 colorInputL = ColorUtils.getValues(LColor);
		 ultrasonicUPInput = UltrasonicUtils.getValue(DistanceUP);
		 
		 //In questa parte sono gestiti tutti i casi possibili in relazione ai valori rilevati dai sensori
		 
		 /*Ostacolo, viene superato girando alla sua destra, caso attivato quando la distanza del sensore ultrasuoni
		  *è minore di 5.5cm*/
		 if(ultrasonicUPInput < 0.055)
		 {
			 Sound.beepSequence();
			 
			 LCD.drawString("ostacolo", 0, 5);
			 		
			 MovementInterface.rotate(75, "cw", RMotor, LMotor);//value changed 105
			 
			 MovementInterface.move(90, "forw", RMotor, LMotor);//value changed 170
			 MovementInterface.rotate(75, "ccw", RMotor, LMotor);
			 
			 MovementInterface.move(165, "forw", RMotor, LMotor);//value changed 280
			 
			 MovementInterface.rotate(75, "ccw", RMotor, LMotor);
			 
			 do {
				 MovementInterface.move(1, "forw", RMotor, LMotor);
				 colorInputR = ColorUtils.getValues(RColor);
			 } while(ColorUtils.white(colorInputR));
			 
			 MovementInterface.move(10, "forw", RMotor, LMotor);
			 
			 /*In questo ciclo il robot ritorna verso sinistra e continua in quella direzione finché non ritrova la linea
			  *e successivamente ritorna in allineamento con la linea*/
			 do {
				 MovementInterface.rotate(1, "cw", RMotor, LMotor);
				 colorInputL = ColorUtils.getValues(LColor);
			 } while(ColorUtils.white(colorInputL));
			 
			 LCD.clear(5);
			 
			 Sound.beepSequenceUp();
		 } 
		 
		 //White-White
		 else if(ColorUtils.white(colorInputR) && ColorUtils.white(colorInputL))
		 {
			 LCD.drawString("white-white", 0, 4);
			 MovementInterface.move(1, "forw", RMotor, LMotor);
			 lastMove = "f";
			 LCD.clear();
		 }
		 
		 //White-Black
		 else if(ColorUtils.white(colorInputR) && ColorUtils.black(colorInputL))
		 {
			 //Qui viene effettuato il cambio di velocità per le curve
			 RMotor.setSpeed(steeringSpeed);
			 LMotor.setSpeed(steeringSpeed);
			 
			 LCD.drawString("white-black", 0, 4);
			 MovementInterface.rotate(1, "ccw", RMotor, LMotor);
			 
			 /*Nei casi con un nero ed un bianco la nuova azione viene memorizzata solo se quella precedente è stata quella
			  *di andare avanti, questo per ridurre i casi in cui un ambiguità di tipo NERO-NERO venga risolta andando in
			  *direzione opposta a quella corretta*/
			 if(lastMove == "f") lastMove = "l";
			 LCD.clear();
			 
			 //Dopo aver eseguito la curva reimposta la velocità dei motori al valore originale
			 RMotor.setSpeed(300);
			 LMotor.setSpeed(300);
		 }
		 
		 //Black-White
		 else if(ColorUtils.black(colorInputR) && ColorUtils.white(colorInputL))
		 {
			RMotor.setSpeed(steeringSpeed);
			LMotor.setSpeed(steeringSpeed);
			
			LCD.drawString("black-white", 0, 4);
			MovementInterface.rotate(1, "cw", RMotor, LMotor);
			if(lastMove == "f") lastMove = "r";
			
			RMotor.setSpeed(300);
			LMotor.setSpeed(300);
		 }
		 
		 //Black-Black
		 else if(ColorUtils.black(colorInputR) && ColorUtils.black(colorInputL))
		 {
			 /*Il caso NERO-NERO è gestito come un'ambiguità in quanto potrebbe essere generato da un incrocio oppure da
			  *una curva stretta. L'ambiguità viene risolta tramite l'utilizzo della variabile "lastMove" che contiene
			  *l'ultima azione eseguita*/
			 LCD.drawString("black-black", 0, 4);
			 
			 //Se l'ultima azione è stata quella di andare dritto, allora il robot si trova ad un incrocio, quindi prosegue dritto
			 if(lastMove == "f") MovementInterface.move(40, "forw", RMotor, LMotor);
			 
			 //Nel caso in cui l'azione precedente sia stata quella di girare ad una curva, si gira in direzione di quella curva
			 else if(lastMove == "r")
			 {
				 /*Prima di intraprendere la curva, c'è una breve rotazione nella direzione opposta. Questa azione funge da
				  *ulteriore sistema di controllo su eventuali fraintendimenti in quanto, così facendo, si evitano casi in cui
				  *un incrocio preso male venga frainteso per una curva in quanto l'ipotetica linea dritta viene rilevata*/
				 LCD.drawString("Curva a destra", 0, 5);
				 MovementInterface.move(45, "forw", RMotor, LMotor);
				 MovementInterface.rotate(31, "ccw", RMotor, LMotor);
				 
				 do {
					 MovementInterface.rotate(2, "cw", RMotor, LMotor);
					 colorInputR = ColorUtils.getValues(RColor);
					 colorInputL = ColorUtils.getValues(LColor);
				 } while(!ColorUtils.black(colorInputR) && !ColorUtils.black(colorInputL));
				 
				 MovementInterface.rotate(2, "cw", RMotor, LMotor);
				 
				 LCD.clear(5);
			 }
			 else if(lastMove == "l")
			 {
				 LCD.drawString("Curva a sinistra", 0, 5);
				 MovementInterface.move(45, "forw", RMotor, LMotor);
				 MovementInterface.rotate(31, "cw", RMotor, LMotor);
				 
				 do {
					 MovementInterface.rotate(2, "ccw", RMotor, LMotor);
					 colorInputL = ColorUtils.getValues(LColor);
					 colorInputR = ColorUtils.getValues(RColor);
				 } while(!ColorUtils.black(colorInputL) && !ColorUtils.black(colorInputR));
				 
				 MovementInterface.rotate(2, "ccw", RMotor, LMotor);
				 
				 LCD.clear(5);
			 }
			 LCD.clear();
		 }
		 
		//silver-silver
		 else if(ColorUtils.silver(colorInputL) || ColorUtils.silver(colorInputR)){
			 //Se l'argento viene rilevato da entrambe i sensori passa direttamente alla zona di evacuazione
			 
			 colorInputL = ColorUtils.getValues(LColor);
			 colorInputR = ColorUtils.getValues(RColor);
			 if(ColorUtils.silver(colorInputL) && ColorUtils.silver(colorInputR))
			 {
				 Sound.twoBeeps();
			 }
			 //Se solo uno dei due sensori rileva l'argento allora significa che la linea è stata raggiunta di sbiego e quindi riaddrizza
			 else if(ColorUtils.silver(colorInputL)) 
			 {
				 Sound.beepSequenceUp();
				 do {
					 MovementInterface.rotate(1, "ccw", RMotor, LMotor);
					 colorInputR = ColorUtils.getValues(RColor);
				 } while(!ColorUtils.silver(colorInputR));
			 }
			 else if(ColorUtils.silver(colorInputR))
			 {
				 Sound.beepSequence();
				 
				 do {
					 MovementInterface.rotate(1, "cw", RMotor, LMotor);
					 colorInputL = ColorUtils.getValues(LColor);
				 } while(!ColorUtils.silver(colorInputL));
			 }
			 
			 EvacuationZone.play();
		 }
		 
		 
		 //Green-Green
		 else if(ColorUtils.green(colorInputL) && ColorUtils.green(colorInputR)){
			 LCD.drawString("green-green", 0, 4);
			 /*Viene effettuata una rotazione iniziale per evitare di incorrere nella linea nera perpendicolare a quella su cui
			  *si trova il robot*/
			 MovementInterface.rotate(110, "cw", RMotor, LMotor);
			 
			 //Successivamente continua la rotazione in maniera dinamica, cioè fermandosi quando incontra la linea nera da cui è arrivato
			 do{
				 MovementInterface.rotate(10, "cw", RMotor, LMotor);
				 colorInputR = ColorUtils.getValues(RColor);
			 }while(ColorUtils.white(colorInputR));
			 LCD.clear();
		 }
		 
		 //Random-Green
		 else if(ColorUtils.green(colorInputR))
		 {			 
			LCD.drawString("random-green", 0, 4);
			//Prima della curva viene fatto un lieve spostamento in avanti per adattarsi a tutti i tipi di curva con verde
			MovementInterface.move(25, "forw", RMotor, LMotor);
			
			do {
				MovementInterface.rotate(2, "cw", RMotor, LMotor);
				
				colorInputR = ColorUtils.getValues(RColor);
			} while(!ColorUtils.black(colorInputR));
			LCD.clear();
		 }
		 
		 //Green-Random
		 else if(ColorUtils.green(colorInputL))
		 {
			 LCD.drawString("green-random", 0, 4);
			 MovementInterface.move(25, "forw", RMotor, LMotor);
			 
			do {
				MovementInterface.rotate(2, "ccw", RMotor, LMotor);
				
				colorInputL = ColorUtils.getValues(LColor);
			} while(!ColorUtils.black(colorInputL));
			LCD.clear();
		 }

		 
		 
	 }//Instruction loop
	 
	 LCD.clear();
	 Sound.playTone(330, 500);
  }
}
